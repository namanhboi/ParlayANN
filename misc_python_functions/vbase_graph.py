import matplotlib.pyplot as plt
import argparse
from textwrap import wrap
import math
import random
import sigmoid_fit
import numpy as np
from scipy.signal import argrelextrema


def parse_input_file(path: str):
    """
    parses file generated by vbase_graph.cpp and returns data for graph
    """
    with open(path, "r") as f:
        # command = f.readline()
        # query_index = int(f.readline())
        lines = [line.rstrip().split(",") for line in f]

    x_axis, y_axis = list(zip(*lines))
    x_axis_values = [int(i) for i in x_axis]
    y_axis_values = [math.log(int(i) + 1) for i in y_axis]
    # y_axis_values = [int(i) for i in y_axis]
    return x_axis_values, y_axis_values


def make_vbase_graph(x_axis, y_axis, num_lines=20):
    """
    create the vbase graph and saves it in the current directory with name : [title].png
    title: should contain information about graph, query node, query params
    x_axis: index of current node in the visisted sequence to query
    y_axis: distance from query
    """
    current_index = 0
    x_y_data = []
    for i in range(99):
        for j in range(current_index + 1, current_index + 100):
            if x_axis[j] == 0:
                x_y_data.append((x_axis[current_index:j], y_axis[current_index:j]))
                
                current_index = j
                break
    random_data_idx = random.sample(range(0, 99), 90)
    alpha = 0.1
    L_arr = []
    x0_arr = []
    k_arr = []
    b_arr = []
    num_dont_fit = 0
    for i in random_data_idx:
        x_axis_data, y_axis_data = x_y_data[i]
        p = plt.plot(x_axis_data, y_axis_data, "x-", alpha=alpha)
        try:
            popt, pcov = sigmoid_fit.fit_sigmoid(x_axis_data, y_axis_data)
            x = np.linspace(0, 30, 500)
            y = sigmoid_fit.sigmoid(x, *popt)
            plt.plot(x, y, alpha = 0.2, color =p[0].get_color())
            L_arr.append(popt[0])
            x0_arr.append(popt[1])
            k_arr.append(popt[2])
            b_arr.append(popt[3])
        except:
            num_dont_fit = num_dont_fit + 1

    print(f"L, mean:{np.mean(L_arr)}, median:{np.median(L_arr)}, std:{np.std(L_arr)}")
    print(f"x0, mean:{np.mean(x0_arr)}, median:{np.median(x0_arr)}, std:{np.std(x0_arr)}")
    print(f"k, mean:{np.mean(k_arr)}, median:{np.median(k_arr)}, std:{np.std(k_arr)}")
    print(f"b, mean:{np.mean(b_arr)}, median:{np.median(b_arr)}, std:{np.std(b_arr)}")
    print(num_dont_fit)

    popt, pcov = sigmoid_fit.fit_sigmoid(x_axis, y_axis)
    x = np.linspace(0, 30, 500)
    y = sigmoid_fit.sigmoid(x, *popt)
    y_d1 = np.gradient(y, x)
    y_d2 = np.gradient(np.gradient(y, x), x)
    argc = argrelextrema(y_d2, np.greater)

    infls = np.where(np.diff(np.sign(y_d2)))[0]
    # plt.scatter(x[infls], y[infls], color="red", label="Inflection Points", zorder=3)
    plt.scatter(x[argc], y[argc], color="red", zorder=3, label = 'local maxima of 2nd derivative')
    # plt.plot(x, y, label = 'fit')
    plt.suptitle("\n".join(wrap("# hops from origin vs log of distance rank", 60)))
    plt.xlabel("Number of hops along path from origin to query")
    plt.ylabel("Log of rank of distance from origin of node")
    plt.text(15, 5, f"L:{popt[0]}\nx0: {popt[1]}\nk:{popt[2]}\nb: {popt[3]}")
    plt.tight_layout()
    plt.legend()
    plt.savefig("vbase_graph.png")


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-p", "--path", help="path to the input file generated by vbase_graph.cpp"
    )
    args = parser.parse_args()
    path = args.path
    x_axis, y_axis = parse_input_file(path)
    make_vbase_graph(x_axis, y_axis)
